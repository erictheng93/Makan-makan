import type { 
  Env, 
  ImageMetadata, 
  ImageProcessingJob, 
  ImageAnalytics,
  ImageTransformation 
} from '../types/env'
import { ImageService as DatabaseImageService, type CreateImageData } from '@makanmakan/database/services'

/**
 * Image service for database operations and metadata management
 */
export class ImageService {
  private db: D1Database
  private cache: KVNamespace
  private dbImageService: DatabaseImageService

  constructor(env: Env) {
    this.db = env.DB
    this.cache = env.IMAGE_CACHE
    this.dbImageService = new DatabaseImageService(env.DB)
  }

  /**
   * Save image metadata to database
   */
  async saveImageMetadata(metadata: Omit<ImageMetadata, 'id'>): Promise<{ success: boolean; id?: string; error?: string }> {
    try {
      // ID will be generated by the database service
      
      // Use database service to create image record
      const imageData: CreateImageData = {
        filename: metadata.filename,
        originalFilename: metadata.originalFilename,
        mimeType: metadata.mimeType,
        size: metadata.size,
        width: metadata.width,
        height: metadata.height,
        category: metadata.category || 'general',
        restaurantId: metadata.restaurantId || 1,
        uploadedBy: metadata.uploadedBy,
        variants: metadata.variants || [],
        metadata: {
          tags: metadata.tags,
          altText: metadata.altText,
          caption: metadata.caption,
          exifData: metadata.exifData
        }
      }
      
      const result = await this.dbImageService.createImage(imageData)
      const imageId = result.id

      // Cache the metadata for quick access
      await this.cache.put(
        `image:${imageId}`,
        JSON.stringify({ id: imageId, ...metadata }),
        { expirationTtl: 3600 } // Cache for 1 hour
      )

      return {
        success: true,
        id: imageId
      }

    } catch (error) {
      console.error('Error saving image metadata:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to save metadata'
      }
    }
  }

  /**
   * Get image metadata by ID
   */
  async getImageMetadata(imageId: string): Promise<{ success: boolean; data?: ImageMetadata; error?: string }> {
    try {
      // Try cache first
      const cached = await this.cache.get(`image:${imageId}`)
      if (cached) {
        return {
          success: true,
          data: JSON.parse(cached)
        }
      }

      // Fetch from database using service
      const result = await this.dbImageService.getImage(imageId)

      if (!result) {
        return {
          success: false,
          error: 'Image not found'
        }
      }

      // Parse metadata from database service result
      const dbMetadata = result.metadata ? JSON.parse(result.metadata) : {}
      const metadata: ImageMetadata = {
        id: result.id,
        filename: result.filename,
        originalFilename: result.originalFilename,
        mimeType: result.mimeType,
        size: result.size,
        width: result.width,
        height: result.height,
        variants: result.variants ? JSON.parse(result.variants) : [],
        uploadedAt: result.uploadedAt,
        uploadedBy: result.uploadedBy,
        restaurantId: result.restaurantId,
        category: result.category,
        tags: dbMetadata.tags,
        altText: dbMetadata.altText,
        caption: dbMetadata.caption,
        exifData: dbMetadata.exifData
      }

      // Cache the result
      await this.cache.put(
        `image:${imageId}`,
        JSON.stringify(metadata),
        { expirationTtl: 3600 }
      )

      return {
        success: true,
        data: metadata
      }

    } catch (error) {
      console.error('Error getting image metadata:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get metadata'
      }
    }
  }

  /**
   * Update image metadata
   */
  async updateImageMetadata(
    imageId: string,
    updates: Partial<Omit<ImageMetadata, 'id' | 'filename' | 'uploadedAt'>>
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const updateFields: string[] = []
      const params: any[] = []

      if (updates.altText !== undefined) {
        updateFields.push('alt_text = ?')
        params.push(updates.altText)
      }

      if (updates.caption !== undefined) {
        updateFields.push('caption = ?')
        params.push(updates.caption)
      }

      if (updates.category !== undefined) {
        updateFields.push('category = ?')
        params.push(updates.category)
      }

      if (updates.tags !== undefined) {
        updateFields.push('tags = ?')
        params.push(updates.tags ? JSON.stringify(updates.tags) : null)
      }

      if (updates.variants !== undefined) {
        updateFields.push('variants = ?')
        params.push(JSON.stringify(updates.variants))
      }

      if (updateFields.length === 0) {
        return {
          success: false,
          error: 'No fields to update'
        }
      }

      updateFields.push('updated_at = datetime(\'now\')')
      params.push(imageId)

      // Use database service for update
      await this.dbImageService.updateImage(imageId, updateData)

      // Invalidate cache
      await this.cache.delete(`image:${imageId}`)

      return { success: true }

    } catch (error) {
      console.error('Error updating image metadata:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to update metadata'
      }
    }
  }

  /**
   * Delete image metadata
   */
  async deleteImageMetadata(imageId: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Use database service for soft delete
      await this.dbImageService.deleteImage(imageId)

      // Remove from cache
      await this.cache.delete(`image:${imageId}`)

      return { success: true }

    } catch (error) {
      console.error('Error deleting image metadata:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to delete metadata'
      }
    }
  }

  /**
   * List images with filtering and pagination
   */
  async listImages(options: {
    restaurantId?: number
    category?: string
    uploadedBy?: number
    tags?: string[]
    page?: number
    limit?: number
    sortBy?: 'uploaded_at' | 'filename' | 'size'
    sortOrder?: 'ASC' | 'DESC'
  } = {}): Promise<{ success: boolean; data?: { images: ImageMetadata[]; total: number }; error?: string }> {
    try {
      const {
        restaurantId,
        category,
        uploadedBy,
        tags,
        page = 1,
        limit = 20,
        sortBy = 'uploaded_at',
        sortOrder = 'DESC'
      } = options

      const whereConditions: string[] = []
      const params: any[] = []

      if (restaurantId !== undefined) {
        whereConditions.push('restaurant_id = ?')
        params.push(restaurantId)
      }

      if (category !== undefined) {
        whereConditions.push('category = ?')
        params.push(category)
      }

      if (uploadedBy !== undefined) {
        whereConditions.push('uploaded_by = ?')
        params.push(uploadedBy)
      }

      if (tags && tags.length > 0) {
        // Simple tag search - could be improved with proper tag table
        const tagConditions = tags.map(() => 'tags LIKE ?').join(' AND ')
        whereConditions.push(`(${tagConditions})`)
        tags.forEach(tag => params.push(`%"${tag}"%`))
      }

      const whereClause = whereConditions.length > 0 
        ? `WHERE ${whereConditions.join(' AND ')}`
        : ''

      // Get total count
      // Use database service for count
      const total = await this.dbImageService.getImagesCount({
        restaurantId: filters.restaurantId,
        category: filters.category
      })
      const countResult = { total }

      const total = countResult?.total as number || 0

      // Get paginated results
      const offset = (page - 1) * limit
      // Use database service for listing images
      const imageResults = await this.dbImageService.getImages({
        restaurantId: filters.restaurantId,
        category: filters.category,
        offset,
        limit
      })
      const images = { results: imageResults }

      const imageList: ImageMetadata[] = (images.results || []).map((row: any) => ({
        id: row.id,
        filename: row.filename,
        originalFilename: row.original_filename,
        mimeType: row.mime_type,
        size: row.size,
        width: row.width,
        height: row.height,
        variants: JSON.parse(row.variants),
        uploadedAt: row.uploaded_at,
        uploadedBy: row.uploaded_by,
        restaurantId: row.restaurant_id,
        category: row.category,
        tags: row.tags ? JSON.parse(row.tags) : undefined,
        altText: row.alt_text,
        caption: row.caption
      }))

      return {
        success: true,
        data: {
          images: imageList,
          total
        }
      }

    } catch (error) {
      console.error('Error listing images:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to list images'
      }
    }
  }

  /**
   * Create processing job
   */
  async createProcessingJob(
    imageId: string,
    transformations: ImageTransformation[],
    variants: string[]
  ): Promise<{ success: boolean; jobId?: string; error?: string }> {
    try {
      const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

      const job: ImageProcessingJob = {
        id: jobId,
        imageId,
        status: 'pending',
        transformations,
        variants,
        createdAt: new Date().toISOString()
      }

      // Use database service to create processing job
      await this.dbImageService.createProcessingJob({
        imageId,
        jobType: 'transformation',
        inputParams: {
          transformations,
          variants
        }
      })

      // Cache job for quick access
      await this.cache.put(`job:${jobId}`, JSON.stringify(job), { expirationTtl: 3600 })

      return {
        success: true,
        jobId
      }

    } catch (error) {
      console.error('Error creating processing job:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to create job'
      }
    }
  }

  /**
   * Update processing job status
   */
  async updateJobStatus(
    jobId: string,
    status: ImageProcessingJob['status'],
    progress?: number,
    error?: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const updateFields = ['status = ?', 'updated_at = datetime(\'now\')']
      const params = [status]

      if (progress !== undefined) {
        updateFields.push('progress = ?')
        params.push(progress)
      }

      if (error !== undefined) {
        updateFields.push('error = ?')
        params.push(error)
      }

      if (status === 'completed') {
        updateFields.push('completed_at = datetime(\'now\')')
      }

      params.push(jobId)

      // FINAL NATIVE SQL ELIMINATED! 🎉 Using Drizzle ORM via DatabaseImageService
      await this.dbImageService.updateProcessingJobStatus(
        parseInt(jobId),
        status, 
        progress !== undefined ? { progress } : undefined,
        error
      )

      // Update cache
      const cached = await this.cache.get(`job:${jobId}`)
      if (cached) {
        const job = JSON.parse(cached)
        job.status = status
        if (progress !== undefined) job.progress = progress
        if (error !== undefined) job.error = error
        if (status === 'completed') job.completedAt = new Date().toISOString()
        
        await this.cache.put(`job:${jobId}`, JSON.stringify(job), { expirationTtl: 3600 })
      }

      return { success: true }

    } catch (error) {
      console.error('Error updating job status:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to update job'
      }
    }
  }

  /**
   * Get processing job status
   */
  async getJobStatus(jobId: string): Promise<{ success: boolean; job?: ImageProcessingJob; error?: string }> {
    try {
      // Try cache first
      const cached = await this.cache.get(`job:${jobId}`)
      if (cached) {
        return {
          success: true,
          job: JSON.parse(cached)
        }
      }

      // Fetch from database
      // Use database service to get processing job
      const result = await this.dbImageService.getProcessingJob(parseInt(jobId))

      if (!result) {
        return {
          success: false,
          error: 'Job not found'
        }
      }

      const job: ImageProcessingJob = {
        id: result.id as string,
        imageId: result.image_id as string,
        status: result.status as ImageProcessingJob['status'],
        transformations: JSON.parse(result.transformations as string),
        variants: JSON.parse(result.variants as string),
        createdAt: result.created_at as string,
        completedAt: result.completed_at as string | undefined,
        error: result.error as string | undefined,
        progress: result.progress as number | undefined
      }

      return {
        success: true,
        job
      }

    } catch (error) {
      console.error('Error getting job status:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get job status'
      }
    }
  }

  /**
   * Get image analytics
   */
  async getImageAnalytics(options: {
    restaurantId?: number
    dateFrom?: string
    dateTo?: string
  } = {}): Promise<{ success: boolean; analytics?: ImageAnalytics; error?: string }> {
    try {
      const { restaurantId, dateFrom, dateTo } = options

      const whereConditions: string[] = []
      const params: any[] = []

      if (restaurantId !== undefined) {
        whereConditions.push('restaurant_id = ?')
        params.push(restaurantId)
      }

      if (dateFrom) {
        whereConditions.push('uploaded_at >= ?')
        params.push(dateFrom)
      }

      if (dateTo) {
        whereConditions.push('uploaded_at <= ?')
        params.push(dateTo)
      }

      const whereClause = whereConditions.length > 0 
        ? `WHERE ${whereConditions.join(' AND ')}`
        : ''

      // Basic statistics
      // Use database service for analytics summary
      const basicStats = await this.dbImageService.getImageAnalyticsSummary()

      // Category breakdown
      // Use database service for category stats
      const categoryStats = await this.dbImageService.getCategoryStats()

      // Processing job statistics
      // Use database service for job stats
      const jobStats = await this.dbImageService.getJobStats()

      const analytics: ImageAnalytics = {
        totalImages: basicStats?.total_images as number || 0,
        totalSize: basicStats?.total_size as number || 0,
        avgProcessingTime: 0, // Will be calculated from job stats
        mostUsedVariants: [], // Would need variant usage tracking
        uploadsByCategory: (categoryStats.results || []).map((row: any) => ({
          category: row.category || 'uncategorized',
          count: row.count
        })),
        errorRate: 0, // Calculate from job stats
        storageUsage: {
          original: basicStats?.total_size as number || 0,
          variants: 0, // Would need variant size tracking
          total: basicStats?.total_size as number || 0
        }
      }

      // Calculate processing metrics from job stats
      const jobResults = jobStats.results || []
      const completedJobs = jobResults.find((row: any) => row.status === 'completed')
      const failedJobs = jobResults.find((row: any) => row.status === 'failed')
      const totalJobs = jobResults.reduce((sum: number, row: any) => sum + row.count, 0)

      if (completedJobs) {
        analytics.avgProcessingTime = completedJobs.avg_processing_time_seconds || 0
      }

      if (failedJobs && totalJobs > 0) {
        analytics.errorRate = (failedJobs.count / totalJobs) * 100
      }

      return {
        success: true,
        analytics
      }

    } catch (error) {
      console.error('Error getting image analytics:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get analytics'
      }
    }
  }

  /**
   * Record image view/access for analytics
   */
  async recordImageView(imageId: string, variant: string = 'original'): Promise<void> {
    try {
      // Use database service for recording views
      await this.dbImageService.recordImageView({
        imageId,
        variant
      })
    } catch (error) {
      // Log error but don't fail the request
      console.error('Error recording image view:', error)
    }
  }
}